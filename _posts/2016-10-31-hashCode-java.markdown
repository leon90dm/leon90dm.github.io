---
layout:     post
title:      "hashCode method performance tuning"
subtitle:   "hashCode method performance tuning"
date:       2016-10-31
author:     "BilboDai"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
    - Java
---

概述
---
HashCode主要的作用就是为了让一个对象作为HashMap或者HashSet里的一个键。因此对象应该实现`equals(Object)`和`hashCode`方法。

- 如果a.equals(b)那么a.hashCode() == b.hashCode()
- 如果hashCode()在同一个对象上调用两次，如果对象没有发生变化，那么结果应该是一样的。

从性能的角度来讲，hashCode的实现的主要考量就是减少共享同一个hash code的对象的数量，也就说要减少哈希冲突的概率。另一方面，如果所有的对象都共享同一个hashcode，那么HashMap或者HashSet的性能将降低成O(n^2)的复杂度。

哈希冲突
---
随机哈希一个很大键的集合的子集出现哈希冲突是不可避免的。例如2,450个键被哈希到1,000,000个槽，即使使用`perfectly uniform random distribution`，也会有95%的概率2个键被哈希到同一个槽中。

####Separate chaining
![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg/900px-Hash_table_5_0_1_1_1_1_1_LL.svg.png)
效率=找到槽（常数时间）+列表遍历（O(n))
一个好的Hash表每个槽应该是空的或者一个元素，偶尔有2到3个，但很少高于3个。

- Separate chaining with linked lists
- Separate chaining with list head cells

####[Open addressing](https://en.wikipedia.org/wiki/Open_addressing)
**Open addressing**又被称为**closed hashing** Java使用的是**Open addressing**所有的记录都被存储在槽中，如果一个新的记录插入之后，那么槽会被校验，从那个槽开始，执行一个探测序列，知道发现 一个没有被占用的槽。检索的时候也是一样，槽都会用相同的探测序列进行扫描知道找到了记录或者找到一个没有被占用的槽（没有找到记录）。

- Linear probing
- Quadratic probing
- Double hashing

####Autogenerated hashCode for long fields
如果把long的高32位和低32位分别取出来做为两个int值进行计算出来的哈希值会更好。如：

```
public int hashCode() {
    int result = (int) val1;
    result = 31 * result + (int) (val1 >>> 32);
    result = 31 * result + (int) val2;
    return 31 * result + (int) (val2 >>> 32);
}
```

虽然hashCode()方法的执行会稍微慢些，但是在哈希集合上使用时效率会更高。
