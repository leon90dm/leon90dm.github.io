I"#<p>Boxing是将原始类型转换为<code class="highlighter-rouge">java.lang.Number</code>的子类<code class="highlighter-rouge">(Java.lang.Byte, Short, Integer, Long, Float, Double)</code>的过程，Boxing是通过<code class="highlighter-rouge">valueOf</code>方法完成的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static Integer valueOf( int i )
</code></pre></div></div>

<p>Unboxing可以通过<code class="highlighter-rouge">java.lang.Number</code>定义的方法转换为它所有的子类的原始类型</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public abstract int intValue();
public abstract long longValue();
public abstract float floatValue();
public abstract double doubleValue();
public byte byteValue() {
    return (byte)intValue();
}
public short shortValue() {
    return (short)intValue();
}
</code></pre></div></div>

<h1 id="implications-on-performance">Implications on performance</h1>

<p>把字符串转换为原始类型的通常都在纠结 <code class="highlighter-rouge">parse*(String)</code> 或者 <code class="highlighter-rouge">valueOf(String)</code> 答案应该是使用<code class="highlighter-rouge">parse*(String)</code>更好，<code class="highlighter-rouge">valueOf(String)</code>会返回一个对象（即使这个对象可能会被缓存）</p>

<p>Number的子类调用<code class="highlighter-rouge">valueOf(primitive_type)</code>使用了缓存，-128到127（都包括）之间的Byte, Short, Integer, Long 类型的数字都被缓存了。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Short i1 = -120;
Short i2 = -120;
System.out.println( i1 == i2 ); //true
</code></pre></div></div>

<p>当然这个值是可以通过参数调整的，如<code class="highlighter-rouge">-Djava.lang.Integer.IntegerCache.high=400</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Integer i1 = -129;
Integer i2 = -129;
System.out.println( i1 == i2 ); //false
Integer i3 = -128;
Integer i4 = -128;
System.out.println( i3 == i4 ); //true
Integer i5 = 400;
Integer i6 = 400;
System.out.println( i5 == i6 ); //true
Integer i7 = 401;
Integer i8 = 401;
System.out.println( i7 == i8 ); //false
</code></pre></div></div>

<h1 id="总结">总结</h1>

<ul>
  <li><code class="highlighter-rouge">java.lang.Float 和 Double</code> 不会被缓存</li>
  <li>不要调用<code class="highlighter-rouge">java.lang.Number</code>子类的<code class="highlighter-rouge"> valueOf(String)</code>方法，无论是是要得到原始类型还是封装类型都应该使用<code class="highlighter-rouge">parse[Type]</code></li>
  <li>不要调用包装类型的构造方法，因为它总会创建一个实例，这样就绕过了缓存。</li>
</ul>
:ET